## 本章目標
>了解各式進位數及補數等邏輯觀念，並概略介紹常見編碼形式，建立後續章節之基礎

## 目錄
* [A1. 前言與聲明](#A1)
* [1. 二進位數](#1)
* [2. 數字基底的轉換](#2)
* [3. 八進位及十六進位數字](#3)
* [4. 數字的補數](#4)
* [5. 二進位有號數](#5)
* [6. 二進位碼](#6)
* [7. 二進位元邏輯](#7)
* [A2. 單字對證](#A2)
* [A3. 後記與參考](#A3)

<h2 id = "A1"> A1. 前言與聲明 </h2>
在進入數位邏輯設計的同時，也意味著你將要開始以數位世界的思維與規則在思考各種觀念與問題，
 
請整理好思緒，別讓自己前後矛盾而混淆了許多簡單的觀念。另有以下幾點聲明須知：

* 本教學歡迎轉載分享，唯獨不得做為商業利益使用，內容援引之範例，其版權皆屬原作者所有
* 講義內容之安排係以國立臺北教育大學數位科技設計學系安排之課程內容為主，若有未提及之處，請善用網路資源
* [A2. 單字對證](#A2)中對於各項專有名詞之名稱將以參考書目為準，若有疑問，請善用網路資源
* 參考書目及其他援引資訊將列於[A3. 後記與參考](#A3)


<h2 id = "1"> 1. 二進位數 </h2>

* 任何一個數字都可以表現成如右的連續係數(更高or更低位數請類推)：	
*a*<sub>3</sub>*a*<sub>2</sub>*a*<sub>1</sub>*a*<sub>0</sub>*.a*<sub>-1</sub>*a*<sub>-2</sub>
* 數字有所謂的 *r* 進位系統，十進位系統只是其中一種，以基底**(base;radix)**決定
* 使用 *r* 進位系統表示一個數值時，其各項係數a<sub>j</sub>必定介於 0~r-1 之間

綜合上述，我們可以將任何一個基底為 *r* 的數字系統，表現成下列的形式：
<center>a<sub>n</sub>⋅r<sup>n</sup> + a<sub>n-1</sub>⋅r<sup>n-1</sup> + ⋅⋅⋅ + a<sub>1</sub>⋅r + a<sub>0</sub> + a<sub>-1</sub>⋅r <sup>-1</sup> + a<sub>-2</sub>⋅r <sup>-2</sup> + ⋅⋅⋅ + a<sub>-m</sub>⋅r <sup>-m</sup></center>

遵循上面的形式，便能計算任一 *n* 進位系統並加總獲得等效的十進位數

常見的進位系統有：二進位、八進位、十進位、十六進位系統等等，其中十六進位系統的係數值介於0~15，前10個數字(0~9)沿用自十進位系統，而10~15等六個數字則依序對應大寫英文字母A~F

---

在算術運算上與十進位相同，當你進行基底為 *r* 的算術運算時所能使用的數元只有 *r* 個(即0 ~ *r*-1)。

* 「時間計算」也是類似概念，因為「時間」本身也可視為一種進位系統(六十進位制)
* 因此，**進位**與**借位**將會是最需要注意的部分

<h2 id = "2"> 2. 數字基底的轉換 </h2>

* 任何一個數字都能用不同基底的進位系統表示出來
* 不同的表示法若具有相同的十進位表示式時，則可稱它們為等值，如：(0011)<sub>8</sub>與(1001)<sub>2</sub>表示成十進位時皆為9，故二者等值

---

至於如何將十進位轉換成基底為 *r* 的表示式，只要利用長除法便能達成，但需要區分成**整數部分**以及**小數部分**

**整數部分**過程如下：

1. 將欲轉換的十進位整數除以 *r*，得到的商先保留，此次結果所得之餘數即為a<sub>0</sub> **(順位持續遞增)**
2. 重複步驟1直至所得的商 < 0 即結束

**小數部分**過程如下：

1. 將欲轉換的十進位小數乘以 *r*，將得到的積拆成「整數」與「小數」，此次結果所得之整數即為a<sub>-1</sub> **(順位持續遞減)**
2. 重複步驟1直至小數部分 = 0 即結束

<h2 id = "3"> 3. 八進位及十六進位數字 </h2>

* 八進位與十六進位的存在可以有效地將等值的二進位數轉換為較簡短的表示式
* 二進位與八進位、十六進位之間的轉換，在於位元之間「拆」與「合」

---

由於2<sup>3</sup> = 8，2<sup>4</sup> = 16，故每一個八進位位元相當於三個二進位位元；同理，每一個十六進位位元相當於四個二進位位元

因此，由二進位轉換成八進位時，只需將數字以**「小數點」**為起點，分別向左右延伸，每三個位元分成一組；同理，轉換成十六進位時就是每四個位元分成一組即可。

至於將八進位或十六進位轉換成二進位的方法則與上述相反，分別拆成三、四個二進位位元即可。

<h2 id = "4"> 4. 數字的補數 </h2>

* 補數的存在，能協助邏輯運算與簡化減法
* 對於一個基底為 *r* 的系統，將擁有兩種補數形式：分別為 *r* 的補數，以及*r*-1的補數
* 對於一個數的補數，進行取補數的動作，將回復成原本的數

---

*r*-1的補數，即是用*r*進位系統之中的最大數減去每個位元，例如：

十進位系統中，546700之9的補數為 999999 - 546700 = 453299 

二進位系統則較為單純，即0與1的對調，例如：1011000之1的補數為0100111

---

*r*的補數則是在*r*-1的最後補數結果再加一，例如：

十進位系統中，012398之10的補數為987602

二進位系統中，1101100之2的補數為0010100

---

前面有提到補數可以用來簡化減法，當兩個*n*位元且基底同樣為*r*的無號數 ***( M - N )*** 相減時，可以透過下面的方法得到答案：

1. 將算式從 ***M -N*** 轉換成 ***M + (N的補數)***
2. 若 ***M ≥ N*** ，算式結果將會擁有一個末端進位*r<sup>n</sup>*，將其去除所剩餘就是 ***M -N*** 的正確結果
3. 若 ***M < N*** ，算式結果不會出現末端進位，但需要將此結果取補數並在前面加上負號，才是正確的結果

---

而無號數的減法也能透過*r*-1完成，但有一項規則需要注意：

1. *r*-1的補數比*r*的補數少1
2. 執行運算後若產生了一個末端進位，其產生的和會比正確結果少1
3. 因此，在移除末端進位以後須再加1，才會是正確的結果

上述的做法稱為 **端迴進位**。

※此規則僅可套用在 **「有產生末端進位」** 的運算結果，倘若沒有末端進位，則運算方法與 *r* 的補數運算方法相同

<h2 id = "5"> 5. 二進位有號數 </h2>

* 欲表示負整數，需要一個表示負值的表示式，但是電腦係以二進位位元來表示所有事情
* 承上述，我們習慣在數字之最左方放置一個位元，0表示正數；1表示負數
* 有號數的表示被稱為**符號大小**表示法

綜合以上，我們以11001為例：

當其為**無號數**時，值為25；當其為**有號數**時，值為-9

---

有號數的加法與一般算術規則相同，唯獨需要注意：

**帶負數的兩個有號二進數加法可以被表示成有號數2的補數形式之兩個數字，包含它們的符號位元做加法，超出符號位元位置的進位捨去。**

有點饒口，我們以( -6 + 13 )作為範例說明：

1. 將-6以2的補數呈現，即11111010，此時最左方的1為符號，代表負值
2. 將13轉換成一般的二進位形式，即00001101，此時最左方的0為符號，代表正值
3. 將兩者相加，得到100000111
4. 去除最左方多出來的符號位元，得到00000111，此時最左方的0為符號，代表正值，得到答案為+7

---

上述的範例可能會有一個疑問 ─ **「為何要使用這麼多的位元數來表示？」**
因為我們需要足夠的位元數去容納**「所有的和」**，我們以( 13 + 14 )作為範例說明：

1. 將13轉換成一般的二進位形式，即01101，此時最左方的0為符號，代表正值
2. 將14轉換成一般的二進位形式，即01110，此時最左方的0為符號，代表正值
3. 將兩者相加，得到11011
4. 去除最左方多出來的符號位元......得到1011， **此處開始出錯！**

當我們一開始就只給兩個*n*位元數相加，而不幸地，所得的和必須用*n* +1個位元來表示就會出錯，這種現象我們稱為**溢位**

---

有號數的減法也很簡單，一樣使用補數的觀念即可完成，直接用(-6)-(-13)的減法做說明：

1. 將-6以2的補數呈現，即11111010，此時最左方的1為符號，代表負值
2. 因負負得正，將(-13)取2的補數變成(+13)，即00001101，此時最左方的0為符號，代表正值
3. 將兩者相加，得到100000111
4. 去除最左方多出來的符號位元，得到00000111，此時最左方的0為符號，代表正值，得到答案為+7

<h2 id = "6"> 6. 二進位碼 </h2>

* 任何不同元件之間，不同的訊息，都可以用二進碼來表示(0或1)
* 隨機的觀察計算機的位元，大部分都是以編碼的資料，而非單純的二進位數

什麼意思呢？
意思是位於計算機的位元，大多已具備二進位數以外的意義，也許是一個運算符號、一個英文字母，**但至少已經不會是基礎的二進位運算**

接下來進入主題以前，再建立幾個觀念：

1. 計算機最常用的系統是二進位系統；但多數人還是習慣十進位系統
2. 解決此狀況的基礎概念是**將十進位轉成二進位計算，再轉回十進位**
3. 如果0和1儲存在計算機內部已經是**編碼**的形式，就可以直接利用十進位系統進行運算

以下介紹將以**二進位編碼十進數(binary-coded decimal)**，通稱為BCD碼為主

---
十進位一共包含十個數字，即0~9，倘若想用二進位碼區分出十個數字則需要4個位元

而4個位元的二進位數會有2<sup>4</sup> = 16種組合，除了0000 ~ 1001 用來代表0~9以外，**還有6種組合被保留著**，這裡請先記得6這個數字

下面以15為範例，呈現BCD碼與二進位數的差異：

BCD碼： 0001 0101

二進位數： 1111

可以看出BCD碼是求出兩側的值再拼成一組表示出15，像是**「編碼」**的感覺；而二進位數則是直接**「計算」**出15這個值

---

BCD的加法算是「編碼的加法」，儘管是以二進位運算的概念為基礎，但還是有點差異，下面舉例說明：

<pre>
EX1: 4+5 = 9
     即0100 + 0101 = 1001

EX2: 4+8 = 12
     這題不能單純的以0100 + 1000 = 1100結束，原因在前面已經提過，十進位系統所使用的組合僅止於0000 ~ 1001而已，
     換言之，此時我們需要強迫二進數系統「進位」
     還記得前面請你記得6這個值嗎？十進數系統中的進位條件是「不小於10」，而二進數系統且位元數為4的進位條件是「不小於16」，差距為6
     
     因此再計算出1100以後，需再加上0110，爾後會得出10010，以BCD碼表示的話即 0001 0010，得出解為12

EX3: 184 + 576 = 760
     面對多位數的運算，須將各位數拆開計算，計算方法與上述兩題相同
     個位數部分： 0100 + 0110 = 1010，因進位需再加上0110，得 1 0000，進位後得到個位數為0
     十位數部分： 1000 + 0111 + 0001 = 10000，因進位需再加上0110，得 1 0110，進位後得到十位數為6
     百位數部分： 0001 + 0101 + 0001 = 0111，無進位，得到百位數為7
</pre>

---
十進位算術當然也能藉由10的補數來達成，而負號則是以9來表示，下面舉例說明：
<pre>
EX1: 375 + (-240) = 135
    將-240轉換成10的補數，即9760，其中9代表負號
	0375 + 9760 = 10135，除去多出來的1，得到0135，且0代表正數，得解
</pre>

---

此處列出其他十進位碼的形式，下文只提出葛雷碼與ASCII碼的基本介紹，有興趣深入了解的人請查閱相關書籍或善用網路資源：

* 2421碼
* 超3碼
* 8,4,-2,-1碼
* 葛雷碼
* ASCII字元碼

<pre>
葛雷碼
又稱灰階編碼，英文為 "Gray code"
特色： 當一個數轉變成下一個數字時，只有一個位元需要改變
用途： 偵錯

EX: 使用二進數，由0111到1000的過程中，需要改變四個位元的值，
此時如果最右邊的位元比起其他三個位元需要花上更多的時間去改變自身的值，則可能會產生一個錯誤數字1001
這就是葛雷碼可以消除的問題，因為葛雷碼每次都只有一個位元需要改變，不可能產生「中間的錯誤」

※需要注意的是，正因為葛雷碼每次只會更動一個位元，在表示上會與一般的二進數稍微不同，需特別留意

</pre>

<pre>
ASCII字元碼
又稱美國資訊交換標準碼，英文為 "American Standard Code for Information Interchange"，簡稱ASCII Code
特色： 用七個位元編碼組成，共128種組合，包含數字、英文(大小寫)字母、符號等等
用途： 協助企業或程式開發等等，能夠更準確地表示數值或特殊字元(如：% , &......)

※部分程式設計上也會運用到ASCII字元碼，至少須記得大小寫字母與數字的起迄
</pre>

下圖是ASCII字元碼的完整表格及資訊：

![https://upload.wikimedia.org/wikipedia/commons/thumb/8/85/ASCII_Code_Chart-Quick_ref_card.jpg/640px-ASCII_Code_Chart-Quick_ref_card.jpg](https://upload.wikimedia.org/wikipedia/commons/thumb/8/85/ASCII_Code_Chart-Quick_ref_card.jpg/640px-ASCII_Code_Chart-Quick_ref_card.jpg)
(圖片來源：維基百科)

---
這節的最後要提到偵錯碼，通常會搭配ASCII使用，但僅給予初步的認識

* 為了能夠檢查ASCII可能產生的錯誤，會在最左邊加上第八個字元來指示同位位元
* 同位位元是用來表示該ASCII中1的總數是偶數或奇數的額外位元，分為**偶同位**與**奇同位**

偶同位是在最左邊插入一個字元，讓字元中的 1 總數為**偶數**；奇同位的手法相同，只不過是讓字元中的 1 總數為**奇數**

<pre>
EX1: A 的ASCII為 1000001
偶同位 = 01000001；奇同位 = 11000001

EX2: T 的ASCII為 1010100
偶同位 = 11010100；奇同位 = 01010100
</pre>

<h2 id = "7"> 7. 二進位元邏輯 </h2>
此處的邏輯與運算不盡相同，以下的值只有0或1，也可稱為**「真與假」、「是與否」**

* 二進位元邏輯包含**二進位變數**以及**一組邏輯運算**
* 基礎的邏輯運算為： AND, OR, NOT，每一種運算必將產生一種結果

三種基本邏輯運算介紹，假設輸入為 *x* 與 *y* ，輸出為 *z*：
<pre>
AND:
符號："·"，或可直接省略
運算式呈現： x·y = z 或 xy = z
意義：當 x 與 y 皆為1時，z = 1，否則z = 0

OR:
符號："+"，不可省略
運算式呈現： x+y = z
意義：當 x 或 y 或同時為1時，z = 1，否則z = 0

NOT:
符號："′"，偶爾會用一槓表示，，針對單一變數使用
運算式呈現： x′ = z
意義：當 x 為1時，z = 0；當 x 為0時，z = 1 ，即z是x的反相，也可視作補數

</pre>

此時要建立一個觀念：**二進位元邏輯 ≠ 二進位算數**

二進位的算術可以有好幾個位元；而邏輯變數只能有一個，以 1+1為例：

二進位算術的1+1 = 10(即十進位的1+1 = 2)；而二進位元邏輯的概念之下，1+1 = 1(即1 OR 1 為1)

另外，對於 *x* 與 *y* 的邏輯運算必定會產生一結果 *z*，並且可以利用**真值表**來列出所有組合方式，例如下圖為 AND 的真值表：
![http://4.bp.blogspot.com/_YGzswHL7aPY/SEme74uFOPI/AAAAAAAAABg/iD__0WQvnFg/s400/%E6%9C%AA%E5%91%BD%E5%90%8D.JPG](http://4.bp.blogspot.com/_YGzswHL7aPY/SEme74uFOPI/AAAAAAAAABg/iD__0WQvnFg/s400/%E6%9C%AA%E5%91%BD%E5%90%8D.JPG)
(圖片來源：網路文章)

---

文章末段要提到邏輯閘的觀念

* 是操作一或多個信號去產生一個輸出信號的**電子電路**
* 是一種硬體方塊圖，無論是上面提到的三個邏輯運算，抑或是後面會提及的其他邏輯運算，皆有各自的圖形符號

下圖為三種邏輯運算所對應的圖形符號：

![http://2.bp.blogspot.com/-XLSuDwJSAC4/U51EgY3F4yI/AAAAAAAAApI/hZjme8Y9X9Q/s1600/%25E5%259C%2596%25E7%2589%25872.png](http://2.bp.blogspot.com/-XLSuDwJSAC4/U51EgY3F4yI/AAAAAAAAApI/hZjme8Y9X9Q/s1600/%25E5%259C%2596%25E7%2589%25872.png)
(圖片來源：網路文章)

最後有一點需要說明，除了NOT閘是一對一以外，輸入的信號並非只能輸入兩個，也可以兩個以上

*w*+*x*+*y* = *z*，或是*ABCD* = *E*也是可行的，但也得遵從該邏輯運算的規則

比如說前者只要*w*,*x*,*y*三者之中至少一變數為1，*z*即為1；而後者必須*A*,*B*,*C*,*D*皆為1，*E*方才為1

<h2 id = "A2"> A2. 單字對證 </h2>

* 二進位 ─ binary
* 八進位 ─ octal
* 十進位 ─ decimal
* 十六進位 ─ hexadecimal
* 基底 ─ base；radix
* 位元 ─ bits
* 位元組 ─ byte
* 補數 ─ complement
* 端迴進位 ─ end-around carry
* 符號補數 ─ signed-complement
* 溢位 ─ overflow
* 真值表 ─ truth table

<h2 id = "A3"> A3. 後記與參考 </h2>
<h4>參考書目</h4>

* 數位邏輯設計 - 滄海書局：[https://www.tsanghai.com.tw/book_detail.php?c=330&no=1212](https://www.tsanghai.com.tw/book_detail.php?c=330&no=1212 "數位邏輯設計 - 滄海書局")
* Digital Design: With an Introduction to the Verilog HDL：[https://www.tenlong.com.tw/products/9780273764526](https://www.tenlong.com.tw/products/9780273764526 "Digital Design: With an Introduction to the Verilog HDL")

<h4>援引資料</h4>

* 維基百科： [https://zh.wikipedia.org/wiki/ASCII](https://zh.wikipedia.org/wiki/ASCII "維基百科")
* 學術文章：[http://f9603230.blogspot.tw/2008/](http://f9603230.blogspot.tw/2008/ "學術文章")
